#### 1.左值引用右值引用

左值（Lvalue，Locator Value）指的是**可以被取地址的值**，即在表达式结束后仍然存在的对象。例如，变量、数组元素、对象等都是左值。

**左值引用**用于绑定左值，并且通常用于传递和修改可变对象。

```cpp
int a = 10;
int& ref = a;  // ref 绑定到 a
ref = 20;      // 修改 ref 也会影响 a
```

右值（Rvalue，Right-hand value）指的是**无法取地址的临时值**，通常是表达式计算的结果，如字面量、临时变量等。

**右值引用**使用 `&&` 语法，用于绑定右值，使得右值可以被高效地移动，而不是复制。

```cpp
int&& rref = 10;  // 10 是右值，可以绑定到右值引用
std::cout << rref << std::endl;  // 输出 10
```

**左值引用 vs 右值引用**

|              | 左值引用 `&`           | 右值引用 `&&`      |
| ------------ | ---------------------- | ------------------ |
| **绑定对象** | 只能绑定左值           | 只能绑定右值       |
| **修改对象** | 可以修改               | 可以修改           |
| **适用场景** | 传递可变对象           | 移动语义、避免拷贝 |
| **常见用法** | 普通变量引用、函数参数 | 移动构造、移动赋值 |

#### 2.左值引用和右值引用的转化

- `std::move()`:是一个**转换工具**，用于将左值**强制转换为右值**，从而触发**移动语义**
- `std::forward<T>()`:主要用于泛型编程，保证在模板参数传递时，保留左右值的**原始属性**，实现**完美转发**。
- `std::move_if_noexcept()`:在某些情况下，如果移动构造可能抛出异常，我们可能更希望使用**拷贝构造**。`std::move_if_noexcept` 可用于这种情况

#### 3.指针的大小与用法

- 指针的大小和编译器的**目标平台的位数**，而**与所指向的数据类型无关**。如果是32位的机器，则指针的大小则是4Byte，如果是64位机器，那么指针的大小是8Byte。
- 指针存储变量的内存地址，使用 `&` 获取地址，使用 `*` 解引用指针以访问数据。
- **指针作为函数参数**：实现**传址调用**，允许函数直接修改原始数据。**函数指针**：用于回调机制或策略模式等

#### 4.指针和引用的区别

**总结对比表**

| 特性               | 指针                    | 引用                        |
| ------------------ | ----------------------- | --------------------------- |
| **是否需要初始化** | 不需要，可以为空        | 必须初始化                  |
| **是否能重新指向** | 可以                    | 不可以                      |
| **是否可为空**     | 可以指向 `nullptr`      | 不可以                      |
| **是否有独立内存** | 是，占用内存存储地址    | 否，与原变量共用内存        |
| **是否可修改值**   | 通过 `*` 解引用后可修改 | 可修改（除非 `const` 修饰） |
| **典型应用场景**   | 动态内存分配、数据结构  | 参数传递、引用更安全的别名  |

#### 5.指针常量和常量指针

**常量指针（`const T*`）**：指向的值**不能修改**，但指针本身的指向**可以更改**。（即只能读，不能修改）

**指针常量（`T* const`）**：指针本身的指向**不能更改**，但指向的值**可以修改**。

#### 6.函数指针的定义

**函数指针 (Function Pointer)** 是指向**函数的地址**的指针。与普通指针不同，函数指针指向的是**可执行代码段**中的函数入口地址，而非数据

 **函数指针的基本语法**

定义函数指针的一般形式为：

```
返回类型 (*指针变量名)(参数类型列表);
```