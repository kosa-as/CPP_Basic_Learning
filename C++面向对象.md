#### 1.面向对象的三大特性：

封装，继承，多态

#### 2.**重载**、**重写 和 **隐藏

| 对比项       | 重载（Overloading）    | 重写（Overriding）                 | 隐藏（Hiding）                                 |
| ------------ | ---------------------- | ---------------------------------- | ---------------------------------------------- |
| **作用域**   | 同一个类               | 继承体系（子类 vs. 父类）          | 继承体系（子类 vs. 父类）                      |
| **函数名**   | 相同                   | 相同                               | 相同                                           |
| **参数列表** | 必须不同               | 必须相同                           | 可相同或不同                                   |
| **返回类型** | 可以不同，但不影响重载 | 不能改变（C++11 允许协变返回类型） | 可以不同                                       |
| **访问方式** | 直接调用               | 通过基类指针或引用调用             | 直接调用                                       |
| **虚函数**   | 无关                   | 必须是 `virtual`                   | 无关                                           |
| **影响**     | 编译期选择不同方法     | 运行时调用子类方法（动态绑定）     | 隐藏父类同名方法，必须使用 `Base::func()` 访问 |

1. **重载（Overloading）** 发生在**同一个类**，**参数不同**，返回值可以不同，属于**编译期多态**。
2. **重写（Overriding）** 发生在**继承体系**，**子类重写基类的虚函数**，必须**函数签名（用于在重载时标识不同的函数）一致**，属于**运行时多态**。
3. **隐藏（Hiding）** 发生在**继承体系**，但不是**虚函数重写**，而是**子类定义了同名函数，隐藏了父类版本**，调用父类方法需要 `Base::func()`。

在实践中，**虚函数重写**是 OOP 里最重要的特性，它允许多态行为，而隐藏可能导致代码难以维护，因此建议避免让子类的方法隐藏父类的方法，除非有特殊需求。

#### 3.多态及其实现办法

- 多态分为运行时多态（通过虚函数实现）和编译时多态（通过函数重载和模板实现）。
- **运行时多态执行的核心步骤**  （运行时多态，虚函数必须为`virtual`,否则可能会引起内存泄漏）
  1. **对象构造时初始化虚函数指针（vptr，存储在对象的实例内存中）**
     - 当对象被构造时，编译器会隐式地在对象内存中插入一个指向**虚函数表（vtable）**的指针（`vptr`）。
     - `vptr` 的值由对象的实际类型决定。例如：
       - `Base` 类型的对象，`vptr` 指向 `Base` 的虚函数表。
       - `Derived` 类型的对象，`vptr` 指向 `Derived` 的虚函数表。
  2. **虚函数表（vtable）的结构**    （**存储在只读数据段中，并且全局唯一**）
     - 每个有虚函数的类都有一个对应的虚函数表（静态存储区）。
     - 虚函数表是一个函数指针数组，每个条目指向该类的虚函数实现。
     - 若派生类覆盖了基类的虚函数，则虚函数表中对应的条目会被替换为派生类的函数地址。
  3. **通过基类指针或引用调用虚函数**    
     - 当通过基类指针或引用调用虚函数时，编译器会生成代码：
       1. 从对象的 `vptr` 找到对应的虚函数表。
       2. 根据虚函数在表中的索引（由编译器确定）找到函数地址。
       3. 调用该函数地址指向的实现。

#### 4.虚函数和纯虚函数

​	在虚函数中，基类需要提供默认实现，并且基类是可以实例化的。但是在纯虚函数中，基类不提供实现（但是可以定义，但是使用必须显示的使用），同时基类不允许被实例化，并且派生类必须覆盖，要给出纯虚函数的实现，否则仍然是抽象类。

​	纯虚函数更多的应用在接口之中，来实现接口和实现的分离，充分体现面向对象的特性。此外，纯虚函数也和虚函数一样，要指定虚构函数，并且为`virtual`

#### 5.多继承

在`CPP`中，与`Java`不同的一点是`CPP`允许多继承。

```cpp
class Derived : public Base1, public Base2 {
    // ...
};
```

但是在多继承中，常见的问题是二义性问题，和棱形问题

- 菱形问题：
  - 当一个派生类从两个或多个基类继承，而这些基类又共同继承自同一个基类时，会导致二义性 和数据冗余 。用虚继承可以解决这个问题

- 二义性问题：
  - 如果多个基类有同名成员，直接访问会引发编译错误。用显式指定基类的作用域可以解决这个问题。



