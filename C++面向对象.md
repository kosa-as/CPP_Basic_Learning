#### 1.面向对象的三大特性：

封装，继承，多态

#### 2.**重载**、**重写 和 **隐藏

| 对比项       | 重载（Overloading）    | 重写（Overriding）                 | 隐藏（Hiding）                                 |
| ------------ | ---------------------- | ---------------------------------- | ---------------------------------------------- |
| **作用域**   | 同一个类               | 继承体系（子类 vs. 父类）          | 继承体系（子类 vs. 父类）                      |
| **函数名**   | 相同                   | 相同                               | 相同                                           |
| **参数列表** | 必须不同               | 必须相同                           | 可相同或不同                                   |
| **返回类型** | 可以不同，但不影响重载 | 不能改变（C++11 允许协变返回类型） | 可以不同                                       |
| **访问方式** | 直接调用               | 通过基类指针或引用调用             | 直接调用                                       |
| **虚函数**   | 无关                   | 必须是 `virtual`                   | 无关                                           |
| **影响**     | 编译期选择不同方法     | 运行时调用子类方法（动态绑定）     | 隐藏父类同名方法，必须使用 `Base::func()` 访问 |

1. **重载（Overloading）** 发生在**同一个类**，**参数不同**，返回值可以不同，属于**编译期多态**。
2. **重写（Overriding）** 发生在**继承体系**，**子类重写基类的虚函数**，必须**函数签名（用于在重载时标识不同的函数）一致**，属于**运行时多态**。
3. **隐藏（Hiding）** 发生在**继承体系**，但不是**虚函数重写**，而是**子类定义了同名函数，隐藏了父类版本**，调用父类方法需要 `Base::func()`。

在实践中，**虚函数重写**是 OOP 里最重要的特性，它允许多态行为，而隐藏可能导致代码难以维护，因此建议避免让子类的方法隐藏父类的方法，除非有特殊需求。

#### 3.多态及其实现办法

- 多态分为运行时多态（通过虚函数实现）和编译时多态（通过函数重载和模板实现）。

- **多态执行的核心步骤**  
  1. **对象构造时初始化虚函数指针（vptr）**    
     - 当对象被构造时，编译器会隐式地在对象内存中插入一个指向**虚函数表（vtable）**的指针（`vptr`）。
     - `vptr` 的值由对象的实际类型决定。例如：
       - `Base` 类型的对象，`vptr` 指向 `Base` 的虚函数表。
       - `Derived` 类型的对象，`vptr` 指向 `Derived` 的虚函数表。
  2. **虚函数表（vtable）的结构**    
     - 每个有虚函数的类都有一个对应的虚函数表（静态存储区）。
     - 虚函数表是一个函数指针数组，每个条目指向该类的虚函数实现。
     - 若派生类覆盖了基类的虚函数，则虚函数表中对应的条目会被替换为派生类的函数地址。
  3. **通过基类指针或引用调用虚函数**    
     - 当通过基类指针或引用调用虚函数时，编译器会生成代码：
       1. 从对象的 `vptr` 找到对应的虚函数表。
       2. 根据虚函数在表中的索引（由编译器确定）找到函数地址。
       3. 调用该函数地址指向的实现。